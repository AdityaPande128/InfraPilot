import * as vscode from 'vscode';
import * as https from 'https';

export function activate(context: vscode.ExtensionContext) {

	console.log('Congratulations, your extension "infrapilot" is now active!');

	const provider = new InfraPilotActivityProvider(context.extensionUri);
	context.subscriptions.push(
		vscode.window.registerWebviewViewProvider(InfraPilotActivityProvider.viewType, provider)
	);

	const disposable = vscode.commands.registerCommand('infrapilot.helloWorld', () => {
		vscode.window.showInformationMessage('Hello World from InfraPilot!');
	});

	// Command to set API key securely
	const setApiKeyCommand = vscode.commands.registerCommand('infrapilot.setApiKey', async () => {
		const apiKey = await vscode.window.showInputBox({
			prompt: 'Enter your Gemini API Key',
			password: true,
			ignoreFocusOut: true
		});

		if (apiKey) {
			await context.secrets.store('infrapilot.geminiApiKey', apiKey);
			vscode.window.showInformationMessage('Gemini API Key saved securely.');
		}
	});

	// Observer for document save
	const saveObserver = vscode.workspace.onDidSaveTextDocument(async (document: vscode.TextDocument) => {
		const fileName = document.fileName;
		if (fileName.endsWith('.py') || fileName.endsWith('.js')) {
			const text = document.getText();
			const keywords = ['boto3', 's3', 'dynamodb', 'google.cloud'];
			const foundKeywords = keywords.filter(keyword => text.includes(keyword));

			if (foundKeywords.length > 0) {
				console.log(`InfraPilot detected cloud activity in ${fileName}`);

				// Retrieve API Key securely (checking for both names so you don't have to re-enter it)
				let apiKey = await context.secrets.get('infrapilot.geminiApiKey');
				if (!apiKey) {
					apiKey = await context.secrets.get('infrapilot.openaiApiKey');
				}

				if (!apiKey) {
					vscode.window.showWarningMessage('InfraPilot: Gemini API Key not set. Please set it using "InfraPilot: Add / Set Gemini API Key" command.');
					return;
				}

				try {
					vscode.window.showInformationMessage('InfraPilot: Analyzing cloud activity with Gemini...');

					// Focus the view
					vscode.commands.executeCommand(`${InfraPilotActivityProvider.viewType}.focus`);

					const policy = await getRequiredPermissions(text, apiKey);
					console.log('Suggested IAM Policy:\n', policy);

					// Send policy to webview for approval
					provider.addPolicyForApproval(policy, fileName);
				} catch (error) {
					vscode.window.showErrorMessage(`InfraPilot Error: ${String(error)}`);
				}
			}
		}
	});

	context.subscriptions.push(disposable, setApiKeyCommand, saveObserver);
}

class InfraPilotActivityProvider implements vscode.WebviewViewProvider {

	public static readonly viewType = 'infrapilot.activityView';

	private _view?: vscode.WebviewView;
	private _pendingPolicy: { policy: string, fileName: string } | null = null;

	constructor(
		private readonly _extensionUri: vscode.Uri,
	) { }

	public resolveWebviewView(
		webviewView: vscode.WebviewView,
		context: vscode.WebviewViewResolveContext,
		_token: vscode.CancellationToken,
	) {
		this._view = webviewView;

		webviewView.webview.options = {
			enableScripts: true,
			localResourceRoots: [
				this._extensionUri
			]
		};

		webviewView.webview.html = this._getHtmlForWebview();

		webviewView.webview.onDidReceiveMessage(async data => {
			switch (data.type) {
				case 'approvePolicy':
					{
						await this.applyPolicyToFile(data.policy);
						break;
					}
			}
		});

		// If a policy was queued before the view resolved, show it now
		if (this._pendingPolicy) {
			this.addPolicyForApproval(this._pendingPolicy.policy, this._pendingPolicy.fileName);
			this._pendingPolicy = null;
		}
	}

	public addPolicyForApproval(policy: string, fileName: string) {
		if (this._view) {
			this._view.webview.postMessage({ type: 'newPolicy', policy: policy, fileName: fileName });
		} else {
			// Queue it for when the view eventually loads
			this._pendingPolicy = { policy, fileName };
		}
	}

	private async applyPolicyToFile(policy: string) {
		const workspaceFolders = vscode.workspace.workspaceFolders;
		if (workspaceFolders && workspaceFolders.length > 0) {
			const rootUri = workspaceFolders[0].uri;
			const mainTfUri = vscode.Uri.joinPath(rootUri, 'main.tf');
			const infrapilotTfUri = vscode.Uri.joinPath(rootUri, 'infrapilot_iam.tf');

			const tfBlock = `resource "aws_iam_policy" "infrapilot_generated_policy_${Date.now()}" {\n  name        = "infrapilot-generated-policy"\n  description = "Auto-generated by InfraPilot"\n  policy      = jsonencode(\n${policy}\n  )\n}\n`;

			let fileExists = false;
			try {
				await vscode.workspace.fs.stat(mainTfUri);
				fileExists = true;
			} catch {
				fileExists = false;
			}

			const edit = new vscode.WorkspaceEdit();
			if (fileExists) {
				const mainTfDoc = await vscode.workspace.openTextDocument(mainTfUri);
				const lastLine = mainTfDoc.lineAt(mainTfDoc.lineCount > 0 ? mainTfDoc.lineCount - 1 : 0);
				const position = mainTfDoc.lineCount > 0 ? lastLine.range.end : new vscode.Position(0, 0);
				const appendText = (mainTfDoc.lineCount > 0 && !lastLine.isEmptyOrWhitespace ? '\n\n' : '') + tfBlock;
				edit.insert(mainTfUri, position, appendText);
			} else {
				edit.createFile(infrapilotTfUri, { ignoreIfExists: true });
				edit.insert(infrapilotTfUri, new vscode.Position(0, 0), tfBlock);
			}

			await vscode.workspace.applyEdit(edit);

			const targetUri = fileExists ? mainTfUri : infrapilotTfUri;
			const targetDoc = await vscode.workspace.openTextDocument(targetUri);
			await targetDoc.save();
			vscode.window.showTextDocument(targetDoc, vscode.ViewColumn.Active);

			vscode.window.showInformationMessage(`InfraPilot: Applied policy to ${fileExists ? 'main.tf' : 'infrapilot_iam.tf'}`);

			// Clear the webview
			if (this._view) {
				this._view.webview.postMessage({ type: 'clear' });
			}
		} else {
			vscode.window.showErrorMessage('InfraPilot: Open a workspace folder first to save Terraform files.');
		}
	}

	private _getHtmlForWebview() {
		return `<!DOCTYPE html>
			<html lang="en">
			<head>
				<meta charset="UTF-8">
				<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<title>InfraPilot Activity</title>
				<style>
					body { font-family: var(--vscode-font-family); padding: 10px; color: var(--vscode-foreground); }
					.card { border: 1px solid var(--vscode-widget-border); padding: 10px; margin-bottom: 10px; border-radius: 4px; background: var(--vscode-editor-background); }
					pre { background: var(--vscode-textCodeBlock-background); padding: 8px; border-radius: 4px; overflow-x: auto; font-size: 12px; }
					button { background: var(--vscode-button-background); color: var(--vscode-button-foreground); border: none; padding: 6px 12px; border-radius: 2px; cursor: pointer; width: 100%; border: 1px solid var(--vscode-button-border, transparent); }
					button:hover { background: var(--vscode-button-hoverBackground); }
				</style>
			</head>
			<body>
				<div id="content"><p>Waiting for cloud activity...</p></div>
				<script>
					const vscode = acquireVsCodeApi();
					let currentPolicy = null;

					window.addEventListener('message', event => {
						const message = event.data;
						switch (message.type) {
							case 'newPolicy':
								currentPolicy = message.policy;
								document.getElementById('content').innerHTML = \`
									<div class="card">
										<h4>Cloud Activity Detected in \${message.fileName.split('/').pop()}</h4>
										<p>Suggested IAM Policy:</p>
										<pre><code>\${currentPolicy}</code></pre>
										<button onclick="approvePolicy()">Approve & Append to Terraform</button>
									</div>
								\`;
								break;
							case 'clear':
								currentPolicy = null;
								document.getElementById('content').innerHTML = '<p>Waiting for cloud activity...</p>';
								break;
						}
					});

					function approvePolicy() {
						if (currentPolicy) {
							vscode.postMessage({ type: 'approvePolicy', policy: currentPolicy });
							document.getElementById('content').innerHTML = '<p>Applying policy...</p>';
						}
					}
				</script>
			</body>
			</html>`;
	}
}

// Helper function to call the Gemini API directly
async function getRequiredPermissions(fileContent: string, apiKey: string): Promise<string> {
	// First, fetch available models for this specific API key to avoid 404s
	const getModelName = (): Promise<string> => {
		return new Promise((resolve, reject) => {
			const req = https.request({
				hostname: 'generativelanguage.googleapis.com',
				path: `/v1beta/models?key=${apiKey}`,
				method: 'GET'
			}, (res) => {
				let body = '';
				res.on('data', chunk => body += chunk);
				res.on('end', () => {
					if (res.statusCode === 200) {
						try {
							const json = JSON.parse(body);
							// Find the first model that supports generateContent and is a Gemini text model
							const models: any[] = json.models || [];
							const validModel = models.find(m =>
								m.supportedGenerationMethods?.includes('generateContent') &&
								m.name.includes('gemini')
							);
							if (validModel) {
								resolve(validModel.name); // E.g. 'models/gemini-2.5-flash'
							} else {
								resolve('models/gemini-2.5-flash'); // fallback
							}
						} catch {
							resolve('models/gemini-2.5-flash');
						}
					} else {
						resolve('models/gemini-2.5-flash');
					}
				});
			});
			req.on('error', () => resolve('models/gemini-2.5-flash'));
			req.end();
		});
	};

	const modelName = await getModelName();

	return new Promise((resolve, reject) => {
		const prompt = 'Analyze this code for Cloud SDK calls. Return only a JSON-formatted AWS IAM policy with least-privilege actions. Do not use wildcards.';
		const data = JSON.stringify({
			contents: [{
				parts: [{
					text: `${prompt}\n\nCode:\n${fileContent}`
				}]
			}]
		});

		const req = https.request({
			hostname: 'generativelanguage.googleapis.com',
			path: `/v1beta/${modelName}:generateContent?key=${apiKey}`,
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				'Content-Length': Buffer.byteLength(data)
			}
		}, (res) => {
			let body = '';
			res.on('data', chunk => body += chunk);
			res.on('end', () => {
				if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
					try {
						const json = JSON.parse(body);
						// Gemini response structure: candidates[0].content.parts[0].text
						let content = json.candidates[0].content.parts[0].text as string;
						// Clean block quotes if returned
						content = content.replace(/^```json\n/, '').replace(/\n```$/, '');
						resolve(content);
					} catch (e) {
						reject(new Error('Failed to parse Gemini response format'));
					}
				} else {
					reject(new Error(`Gemini API Error: ${res.statusCode} ${body}`));
				}
			});
		});

		req.on('error', reject);
		req.write(data);
		req.end();
	});
}

// This method is called when your extension is deactivated
export function deactivate() { }
